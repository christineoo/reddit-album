(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{209:function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mitt = __webpack_require__(719);\n\nvar _mitt2 = _interopRequireDefault(_mitt);\n\nvar _tabbable = __webpack_require__(720);\n\nvar _tabbable2 = _interopRequireDefault(_tabbable);\n\nvar _animationBus = __webpack_require__(538);\n\nvar _animationBus2 = _interopRequireDefault(_animationBus);\n\nvar _resizeObserverPolyfill = __webpack_require__(723);\n\nvar _resizeObserverPolyfill2 = _interopRequireDefault(_resizeObserverPolyfill);\n\nvar _PagerElement3 = __webpack_require__(724);\n\nvar _PagerElement4 = _interopRequireDefault(_PagerElement3);\n\nvar _utils = __webpack_require__(514);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar TRANSFORM = __webpack_require__(725)('transform');\nvar isWindowDefined = typeof window !== 'undefined';\n\nvar Track = function (_PagerElement) {\n  _inherits(Track, _PagerElement);\n\n  function Track() {\n    _classCallCheck(this, Track);\n\n    return _possibleConstructorReturn(this, (Track.__proto__ || Object.getPrototypeOf(Track)).apply(this, arguments));\n  }\n\n  _createClass(Track, [{\n    key: 'getStyles',\n    value: function getStyles(trackPosition) {\n      var _pager$getPositionVal = this.pager.getPositionValue(trackPosition),\n          x = _pager$getPositionVal.x,\n          y = _pager$getPositionVal.y;\n\n      var trackSize = this.pager.getTrackSize();\n      var style = _defineProperty({}, TRANSFORM, 'translate3d(' + x + 'px, ' + y + 'px, 0)');\n\n      if (trackSize) {\n        var _pager$options = this.pager.options,\n            axis = _pager$options.axis,\n            viewsToShow = _pager$options.viewsToShow;\n\n        var dimension = axis === 'x' ? 'width' : 'height';\n\n        style[dimension] = viewsToShow === 'auto' ? trackSize : this.pager.views.length / viewsToShow * 100 + '%';\n      }\n\n      return style;\n    }\n  }]);\n\n  return Track;\n}(_PagerElement4.default);\n\nvar View = function (_PagerElement2) {\n  _inherits(View, _PagerElement2);\n\n  function View(_ref) {\n    var index = _ref.index,\n        restOptions = _objectWithoutProperties(_ref, ['index']);\n\n    _classCallCheck(this, View);\n\n    var _this2 = _possibleConstructorReturn(this, (View.__proto__ || Object.getPrototypeOf(View)).call(this, restOptions));\n\n    _this2.index = index;\n    _this2.inBounds = true;\n    _this2.tabbableChildren = [];\n    _this2.setCurrent(false);\n    _this2.setVisible(false);\n    _this2.setTarget();\n    _this2.setOrigin();\n\n    // TODO: look into getting rid of setTimeout\n    // not sure the reason for needing setTimeout in order to get proper children,\n    // might be due to something in React that we're not doing at the right time\n    setTimeout(function () {\n      _this2.tabbableChildren = (0, _tabbable2.default)(_this2.node);\n      _this2.setTabbableChildren();\n    });\n    return _this2;\n  }\n\n  _createClass(View, [{\n    key: 'setCurrent',\n    value: function setCurrent(isCurrent) {\n      this.isCurrent = isCurrent;\n    }\n  }, {\n    key: 'setVisible',\n    value: function setVisible(isVisible) {\n      this.isVisible = isVisible;\n      this.setTabbableChildren();\n    }\n  }, {\n    key: 'setTabbableChildren',\n    value: function setTabbableChildren() {\n      // only allow tabbing in current slides\n      for (var i = 0; i < this.tabbableChildren.length; i++) {\n        this.tabbableChildren[i].tabIndex = this.isCurrent ? 0 : -1;\n      }\n    }\n  }, {\n    key: 'setTarget',\n    value: function setTarget() {\n      var _pager$options2 = this.pager.options,\n          align = _pager$options2.align,\n          viewsToShow = _pager$options2.viewsToShow;\n\n      var target = this.pager.getStartCoords(this.index);\n\n      if (align) {\n        target += this.pager.getAlignOffset(this);\n      }\n\n      this.target = target;\n    }\n  }, {\n    key: 'setOrigin',\n    value: function setOrigin() {\n      var trackPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pager.trackPosition;\n\n      this.origin = this.target - trackPosition;\n    }\n  }, {\n    key: 'getStyles',\n    value: function getStyles() {\n      var _pager$options3 = this.pager.options,\n          axis = _pager$options3.axis,\n          viewsToShow = _pager$options3.viewsToShow,\n          infinite = _pager$options3.infinite;\n\n      var style = {};\n\n      // we need to position views inline when using the x axis\n      if (axis === 'x') {\n        style.display = 'inline-block';\n        style.verticalAlign = 'top';\n      }\n\n      // set width or height on view when viewsToShow is not auto\n      if (viewsToShow !== 'auto') {\n        style[axis === 'x' ? 'width' : 'height'] = 100 / this.pager.views.length + '%';\n      }\n\n      // make sure view stays in frame when using infinite option\n      if (infinite && !this.inBounds) {\n        style.position = 'relative';\n        style[axis === 'y' ? 'top' : 'left'] = this.getPosition();\n      }\n\n      // finally, apply any animations\n      return _extends({}, style, this.pager.animationBus.getStyles(this));\n    }\n  }]);\n\n  return View;\n}(_PagerElement4.default);\n\nvar defaultOptions = {\n  viewsToShow: 1,\n  viewsToMove: 1,\n  align: 0,\n  contain: false,\n  axis: 'x',\n  autoSize: false,\n  animations: [],\n  infinite: false,\n  instant: false,\n  swipe: true,\n  swipeThreshold: 0.5,\n  flickTimeout: 300,\n  accessibility: true\n};\n\nvar Pager = function () {\n  function Pager() {\n    var _this3 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Pager);\n\n    this.hydrate = function () {\n      _this3.frame.setSize();\n      _this3.track.setSize();\n      _this3.views.forEach(function (view) {\n        view.setSize();\n        view.setTarget();\n      });\n      _this3.setPositionValue();\n      _this3.setViewStyles();\n      _this3.emit('hydrated');\n    };\n\n    var emitter = (0, _mitt2.default)();\n\n    this.on = emitter.on;\n    this.emit = emitter.emit;\n    this.off = emitter.off;\n\n    this.views = [];\n    this.currentIndex = 0;\n    this.currentView = null;\n    this.currentTween = 0;\n    this.trackPosition = 0;\n    this.isSwiping = false;\n\n    this.options = _extends({}, defaultOptions, options);\n\n    this.animationBus = new _animationBus2.default({\n      animations: this.options.animations,\n      origin: function origin(view) {\n        return view.origin;\n      }\n    });\n\n    if (isWindowDefined) {\n      this.resizeObserver = new _resizeObserverPolyfill2.default(function () {\n        _this3.hydrate();\n      });\n    }\n  }\n\n  _createClass(Pager, [{\n    key: 'setOptions',\n    value: function setOptions(options) {\n      var lastOptions = this.options;\n\n      // spread new options over the old ones\n      this.options = _extends({}, this.options, options);\n\n      // merge animations into animation bus\n      this.animationBus.animations = this.options.animations;\n\n      // fire a viewChange event with the new indicies if viewsToShow has changed\n      if (lastOptions.viewsToShow !== this.options.viewsToShow) {\n        this.emit('viewChange', this.getCurrentIndicies());\n      }\n    }\n  }, {\n    key: 'addFrame',\n    value: function addFrame(node) {\n      this.frame = new _PagerElement4.default({\n        node: node,\n        pager: this\n      });\n    }\n  }, {\n    key: 'addTrack',\n    value: function addTrack(node) {\n      this.track = new Track({\n        node: node,\n        pager: this\n      });\n    }\n  }, {\n    key: 'addView',\n    value: function addView(node) {\n      var index = this.views.length;\n      var view = new View({\n        node: node,\n        index: index,\n        pager: this\n      });\n\n      // add view to collection\n      this.views.push(view);\n\n      // set this as the first view if there isn't one yet\n      if (!this.currentView) {\n        this.setCurrentView({\n          index: index,\n          suppressEvent: true\n        });\n      }\n\n      // listen for width and height changes\n      if (isWindowDefined) {\n        this.resizeObserver.observe(node);\n      }\n\n      // fire an event\n      this.emit('viewAdded');\n\n      return view;\n    }\n  }, {\n    key: 'removeView',\n    value: function removeView(view) {\n      // filter out view\n      this.views = this.views.filter(function (_view) {\n        return view !== _view;\n      });\n\n      // stop observing node\n      if (isWindowDefined) {\n        this.resizeObserver.disconnect(view.node);\n      }\n\n      // fire an event\n      this.emit('viewRemoved');\n    }\n  }, {\n    key: 'prev',\n    value: function prev() {\n      this.setCurrentView({ direction: -1 });\n    }\n  }, {\n    key: 'next',\n    value: function next() {\n      this.setCurrentView({ direction: 1 });\n    }\n  }, {\n    key: 'setCurrentView',\n    value: function setCurrentView(_ref2) {\n      var _ref2$direction = _ref2.direction,\n          direction = _ref2$direction === undefined ? 0 : _ref2$direction,\n          _ref2$index = _ref2.index,\n          index = _ref2$index === undefined ? this.currentIndex : _ref2$index,\n          _ref2$suppressEvent = _ref2.suppressEvent,\n          suppressEvent = _ref2$suppressEvent === undefined ? false : _ref2$suppressEvent;\n      var _options = this.options,\n          viewsToMove = _options.viewsToMove,\n          infinite = _options.infinite;\n\n      var newIndex = index + direction * viewsToMove;\n\n      var previousIndex = this.currentIndex;\n      var currentIndex = infinite ? newIndex : (0, _utils.clamp)(newIndex, 0, this.views.length - 1);\n\n      var previousView = this.getView(previousIndex);\n      var currentView = this.getView(currentIndex);\n\n      // set current index and view\n      this.currentIndex = currentIndex;\n      this.currentView = currentView;\n\n      // swap current view flags\n      previousView.setCurrent(false);\n      currentView.setCurrent(true);\n\n      var rangeStart = currentIndex;\n      var rangeEnd = currentIndex + viewsToMove - 1;\n      var viewRange = (0, _utils.range)(rangeStart, rangeEnd, this.views.length);\n\n      // set flags for which views are currently showing\n      this.views.forEach(function (view, index) {\n        view.setVisible(index === currentIndex);\n      });\n\n      // set the track position to the new view\n      this.setPositionValue();\n\n      if (!suppressEvent) {\n        this.emit('viewChange', this.getCurrentIndicies());\n      }\n    }\n  }, {\n    key: 'setPositionValue',\n    value: function setPositionValue() {\n      var trackPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentView ? this.currentView.target : 0;\n\n      if (!this.isSwiping) {\n        var _options2 = this.options,\n            viewsToShow = _options2.viewsToShow,\n            autoSize = _options2.autoSize,\n            infinite = _options2.infinite,\n            contain = _options2.contain;\n\n        var trackSize = this.getTrackSize();\n\n        if (infinite) {\n          // we offset by a track multiplier so infinite animation can take advantage of\n          // physics by animating to a large value, the final value provided in getTransformValue\n          // will return the proper wrapped value\n          trackPosition -= (Math.floor(this.currentIndex / this.views.length) || 0) * trackSize;\n        }\n\n        if (contain) {\n          var trackEndOffset = viewsToShow === 'auto' && autoSize || viewsToShow <= 1 ? 0 : this.getFrameSize({ autoSize: false });\n          trackPosition = (0, _utils.clamp)(trackPosition, trackEndOffset - trackSize, 0);\n        }\n      }\n\n      this.trackPosition = trackPosition;\n    }\n  }, {\n    key: 'setViewStyles',\n    value: function setViewStyles() {\n      var trackPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var _options3 = this.options,\n          infinite = _options3.infinite,\n          align = _options3.align;\n\n      var frameSize = this.getFrameSize();\n      var trackSize = this.getTrackSize();\n      var wrappedtrackPosition = (0, _utils.modulo)(trackPosition, -trackSize);\n\n      this.views.reduce(function (lastPosition, view, index) {\n        var viewSize = view.getSize();\n        var nextPosition = lastPosition + viewSize;\n        var position = lastPosition;\n\n        if (nextPosition + viewSize * align < Math.abs(wrappedtrackPosition)) {\n          // shift views around so they are always visible in frame\n          if (infinite) {\n            position += trackSize - lastPosition;\n          }\n          view.inBounds = false;\n        } else {\n          view.inBounds = true;\n        }\n\n        view.setPosition(position);\n        view.setOrigin(trackPosition);\n\n        return nextPosition;\n      }, 0);\n    }\n  }, {\n    key: 'getNumericViewsToShow',\n    value: function getNumericViewsToShow() {\n      return isNaN(this.options.viewsToShow) ? 1 : this.options.viewsToShow;\n    }\n  }, {\n    key: 'getMaxDimensions',\n    value: function getMaxDimensions(indices) {\n      var _this4 = this;\n\n      var axis = this.options.axis;\n\n      var widths = [];\n      var heights = [];\n\n      indices.forEach(function (index) {\n        var view = isNaN(index) ? index : _this4.getView(index);\n        widths.push(view.getSize('width'));\n        heights.push(view.getSize('height'));\n      });\n\n      return {\n        width: axis === 'x' ? (0, _utils.sum)(widths) : (0, _utils.max)(widths),\n        height: axis === 'y' ? (0, _utils.sum)(heights) : (0, _utils.max)(heights)\n      };\n    }\n  }, {\n    key: 'getCurrentIndicies',\n    value: function getCurrentIndicies() {\n      var _options4 = this.options,\n          infinite = _options4.infinite,\n          contain = _options4.contain;\n\n      var currentViews = [];\n      var viewsToShow = isNaN(this.options.viewsToShow) ? 1 : this.options.viewsToShow;\n      var minIndex = this.currentIndex;\n      var maxIndex = this.currentIndex + (viewsToShow - 1);\n\n      if (contain) {\n        // if containing, we need to clamp the start and end indexes so we only return what's in view\n        minIndex = (0, _utils.clamp)(minIndex, 0, this.views.length - viewsToShow);\n        maxIndex = (0, _utils.clamp)(maxIndex, 0, this.views.length - 1);\n        for (var i = minIndex; i <= maxIndex; i++) {\n          currentViews.push(i);\n        }\n      } else {\n        for (var _i = minIndex; _i <= maxIndex; _i++) {\n          currentViews.push(infinite ? (0, _utils.modulo)(_i, this.views.length) : (0, _utils.clamp)(_i, 0, this.views.length - 1));\n        }\n      }\n\n      return currentViews;\n    }\n  }, {\n    key: 'getFrameSize',\n    value: function getFrameSize() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref3$autoSize = _ref3.autoSize,\n          autoSize = _ref3$autoSize === undefined ? this.options.autoSize : _ref3$autoSize,\n          _ref3$fullSize = _ref3.fullSize,\n          fullSize = _ref3$fullSize === undefined ? false : _ref3$fullSize;\n\n      var dimensions = {\n        width: 0,\n        height: 0\n      };\n\n      if (this.views.length) {\n        if (autoSize) {\n          var currentViews = this.getCurrentIndicies();\n          dimensions = this.getMaxDimensions(currentViews);\n        } else if (this.frame) {\n          dimensions = {\n            width: this.frame.getSize('width'),\n            height: this.frame.getSize('height')\n          };\n        }\n      }\n\n      if (fullSize) {\n        return dimensions;\n      } else {\n        return dimensions[this.options.axis === 'x' ? 'width' : 'height'];\n      }\n    }\n  }, {\n    key: 'getTrackSize',\n    value: function getTrackSize() {\n      var includeLastSlide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      var lastIndex = includeLastSlide ? this.views.length : this.views.length - 1;\n      var size = 0;\n      this.views.slice(0, lastIndex).forEach(function (view) {\n        size += view.getSize();\n      });\n      return size;\n    }\n  }, {\n    key: 'getView',\n    value: function getView(index) {\n      return this.views[(0, _utils.modulo)(index, this.views.length)];\n    }\n\n    // where the view should start\n\n  }, {\n    key: 'getStartCoords',\n    value: function getStartCoords(index) {\n      var target = 0;\n      this.views.slice(0, index).forEach(function (view) {\n        target -= view.getSize();\n      });\n      return target;\n    }\n\n    // how much to offset the view defined by the align option\n\n  }, {\n    key: 'getAlignOffset',\n    value: function getAlignOffset(view) {\n      var frameSize = this.getFrameSize({ autoSize: false });\n      var viewSize = view.getSize();\n      return (frameSize - viewSize) * this.options.align;\n    }\n  }, {\n    key: 'getPositionValue',\n    value: function getPositionValue() {\n      var trackPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.trackPosition;\n      var _options5 = this.options,\n          infinite = _options5.infinite,\n          contain = _options5.contain;\n\n      var position = { x: 0, y: 0\n\n        // store the current animated value so we can reference it later\n      };this.currentTween = trackPosition;\n\n      // wrap the track position if this is an infinite track\n      if (infinite) {\n        var trackSize = this.getTrackSize();\n        trackPosition = (0, _utils.modulo)(trackPosition, -trackSize) || 0;\n      }\n\n      // emit a \"scroll\" event so we can do things based on the progress of the track\n      this.emit('scroll', {\n        progress: trackPosition / this.getTrackSize(false),\n        position: trackPosition\n      });\n\n      // set the proper transform axis based on our options\n      position[this.options.axis] = trackPosition;\n\n      return position;\n    }\n  }, {\n    key: 'resetViewIndex',\n    value: function resetViewIndex() {\n      // reset back to a normal index\n      this.setCurrentView({\n        index: (0, _utils.modulo)(this.currentIndex, this.views.length),\n        suppressEvent: true\n      });\n    }\n  }]);\n\n  return Pager;\n}();\n\nexports.default = Pager;\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXZpZXctcGFnZXIvbGliL1BhZ2VyLmpzPzhkOGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX21pdHQgPSByZXF1aXJlKCdtaXR0Jyk7XG5cbnZhciBfbWl0dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9taXR0KTtcblxudmFyIF90YWJiYWJsZSA9IHJlcXVpcmUoJ3RhYmJhYmxlJyk7XG5cbnZhciBfdGFiYmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiYmFibGUpO1xuXG52YXIgX2FuaW1hdGlvbkJ1cyA9IHJlcXVpcmUoJ2FuaW1hdGlvbi1idXMnKTtcblxudmFyIF9hbmltYXRpb25CdXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYW5pbWF0aW9uQnVzKTtcblxudmFyIF9yZXNpemVPYnNlcnZlclBvbHlmaWxsID0gcmVxdWlyZSgncmVzaXplLW9ic2VydmVyLXBvbHlmaWxsJyk7XG5cbnZhciBfcmVzaXplT2JzZXJ2ZXJQb2x5ZmlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZXNpemVPYnNlcnZlclBvbHlmaWxsKTtcblxudmFyIF9QYWdlckVsZW1lbnQzID0gcmVxdWlyZSgnLi9QYWdlckVsZW1lbnQnKTtcblxudmFyIF9QYWdlckVsZW1lbnQ0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGFnZXJFbGVtZW50Myk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVFJBTlNGT1JNID0gcmVxdWlyZSgnZ2V0LXByZWZpeCcpKCd0cmFuc2Zvcm0nKTtcbnZhciBpc1dpbmRvd0RlZmluZWQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxudmFyIFRyYWNrID0gZnVuY3Rpb24gKF9QYWdlckVsZW1lbnQpIHtcbiAgX2luaGVyaXRzKFRyYWNrLCBfUGFnZXJFbGVtZW50KTtcblxuICBmdW5jdGlvbiBUcmFjaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhY2spO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUcmFjay5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRyYWNrKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVHJhY2ssIFt7XG4gICAga2V5OiAnZ2V0U3R5bGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3R5bGVzKHRyYWNrUG9zaXRpb24pIHtcbiAgICAgIHZhciBfcGFnZXIkZ2V0UG9zaXRpb25WYWwgPSB0aGlzLnBhZ2VyLmdldFBvc2l0aW9uVmFsdWUodHJhY2tQb3NpdGlvbiksXG4gICAgICAgICAgeCA9IF9wYWdlciRnZXRQb3NpdGlvblZhbC54LFxuICAgICAgICAgIHkgPSBfcGFnZXIkZ2V0UG9zaXRpb25WYWwueTtcblxuICAgICAgdmFyIHRyYWNrU2l6ZSA9IHRoaXMucGFnZXIuZ2V0VHJhY2tTaXplKCk7XG4gICAgICB2YXIgc3R5bGUgPSBfZGVmaW5lUHJvcGVydHkoe30sIFRSQU5TRk9STSwgJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJ3B4LCAnICsgeSArICdweCwgMCknKTtcblxuICAgICAgaWYgKHRyYWNrU2l6ZSkge1xuICAgICAgICB2YXIgX3BhZ2VyJG9wdGlvbnMgPSB0aGlzLnBhZ2VyLm9wdGlvbnMsXG4gICAgICAgICAgICBheGlzID0gX3BhZ2VyJG9wdGlvbnMuYXhpcyxcbiAgICAgICAgICAgIHZpZXdzVG9TaG93ID0gX3BhZ2VyJG9wdGlvbnMudmlld3NUb1Nob3c7XG5cbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IGF4aXMgPT09ICd4JyA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICAgICAgICBzdHlsZVtkaW1lbnNpb25dID0gdmlld3NUb1Nob3cgPT09ICdhdXRvJyA/IHRyYWNrU2l6ZSA6IHRoaXMucGFnZXIudmlld3MubGVuZ3RoIC8gdmlld3NUb1Nob3cgKiAxMDAgKyAnJSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJhY2s7XG59KF9QYWdlckVsZW1lbnQ0LmRlZmF1bHQpO1xuXG52YXIgVmlldyA9IGZ1bmN0aW9uIChfUGFnZXJFbGVtZW50Mikge1xuICBfaW5oZXJpdHMoVmlldywgX1BhZ2VyRWxlbWVudDIpO1xuXG4gIGZ1bmN0aW9uIFZpZXcoX3JlZikge1xuICAgIHZhciBpbmRleCA9IF9yZWYuaW5kZXgsXG4gICAgICAgIHJlc3RPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnaW5kZXgnXSk7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlldyk7XG5cbiAgICB2YXIgX3RoaXMyID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFZpZXcuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihWaWV3KSkuY2FsbCh0aGlzLCByZXN0T3B0aW9ucykpO1xuXG4gICAgX3RoaXMyLmluZGV4ID0gaW5kZXg7XG4gICAgX3RoaXMyLmluQm91bmRzID0gdHJ1ZTtcbiAgICBfdGhpczIudGFiYmFibGVDaGlsZHJlbiA9IFtdO1xuICAgIF90aGlzMi5zZXRDdXJyZW50KGZhbHNlKTtcbiAgICBfdGhpczIuc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgX3RoaXMyLnNldFRhcmdldCgpO1xuICAgIF90aGlzMi5zZXRPcmlnaW4oKTtcblxuICAgIC8vIFRPRE86IGxvb2sgaW50byBnZXR0aW5nIHJpZCBvZiBzZXRUaW1lb3V0XG4gICAgLy8gbm90IHN1cmUgdGhlIHJlYXNvbiBmb3IgbmVlZGluZyBzZXRUaW1lb3V0IGluIG9yZGVyIHRvIGdldCBwcm9wZXIgY2hpbGRyZW4sXG4gICAgLy8gbWlnaHQgYmUgZHVlIHRvIHNvbWV0aGluZyBpbiBSZWFjdCB0aGF0IHdlJ3JlIG5vdCBkb2luZyBhdCB0aGUgcmlnaHQgdGltZVxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMyLnRhYmJhYmxlQ2hpbGRyZW4gPSAoMCwgX3RhYmJhYmxlMi5kZWZhdWx0KShfdGhpczIubm9kZSk7XG4gICAgICBfdGhpczIuc2V0VGFiYmFibGVDaGlsZHJlbigpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVmlldywgW3tcbiAgICBrZXk6ICdzZXRDdXJyZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3VycmVudChpc0N1cnJlbnQpIHtcbiAgICAgIHRoaXMuaXNDdXJyZW50ID0gaXNDdXJyZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFZpc2libGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWaXNpYmxlKGlzVmlzaWJsZSkge1xuICAgICAgdGhpcy5pc1Zpc2libGUgPSBpc1Zpc2libGU7XG4gICAgICB0aGlzLnNldFRhYmJhYmxlQ2hpbGRyZW4oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRUYWJiYWJsZUNoaWxkcmVuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGFiYmFibGVDaGlsZHJlbigpIHtcbiAgICAgIC8vIG9ubHkgYWxsb3cgdGFiYmluZyBpbiBjdXJyZW50IHNsaWRlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRhYmJhYmxlQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy50YWJiYWJsZUNoaWxkcmVuW2ldLnRhYkluZGV4ID0gdGhpcy5pc0N1cnJlbnQgPyAwIDogLTE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0VGFyZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGFyZ2V0KCkge1xuICAgICAgdmFyIF9wYWdlciRvcHRpb25zMiA9IHRoaXMucGFnZXIub3B0aW9ucyxcbiAgICAgICAgICBhbGlnbiA9IF9wYWdlciRvcHRpb25zMi5hbGlnbixcbiAgICAgICAgICB2aWV3c1RvU2hvdyA9IF9wYWdlciRvcHRpb25zMi52aWV3c1RvU2hvdztcblxuICAgICAgdmFyIHRhcmdldCA9IHRoaXMucGFnZXIuZ2V0U3RhcnRDb29yZHModGhpcy5pbmRleCk7XG5cbiAgICAgIGlmIChhbGlnbikge1xuICAgICAgICB0YXJnZXQgKz0gdGhpcy5wYWdlci5nZXRBbGlnbk9mZnNldCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0T3JpZ2luJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3JpZ2luKCkge1xuICAgICAgdmFyIHRyYWNrUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMucGFnZXIudHJhY2tQb3NpdGlvbjtcblxuICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLnRhcmdldCAtIHRyYWNrUG9zaXRpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0U3R5bGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3R5bGVzKCkge1xuICAgICAgdmFyIF9wYWdlciRvcHRpb25zMyA9IHRoaXMucGFnZXIub3B0aW9ucyxcbiAgICAgICAgICBheGlzID0gX3BhZ2VyJG9wdGlvbnMzLmF4aXMsXG4gICAgICAgICAgdmlld3NUb1Nob3cgPSBfcGFnZXIkb3B0aW9uczMudmlld3NUb1Nob3csXG4gICAgICAgICAgaW5maW5pdGUgPSBfcGFnZXIkb3B0aW9uczMuaW5maW5pdGU7XG5cbiAgICAgIHZhciBzdHlsZSA9IHt9O1xuXG4gICAgICAvLyB3ZSBuZWVkIHRvIHBvc2l0aW9uIHZpZXdzIGlubGluZSB3aGVuIHVzaW5nIHRoZSB4IGF4aXNcbiAgICAgIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgICAgc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgICBzdHlsZS52ZXJ0aWNhbEFsaWduID0gJ3RvcCc7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCB3aWR0aCBvciBoZWlnaHQgb24gdmlldyB3aGVuIHZpZXdzVG9TaG93IGlzIG5vdCBhdXRvXG4gICAgICBpZiAodmlld3NUb1Nob3cgIT09ICdhdXRvJykge1xuICAgICAgICBzdHlsZVtheGlzID09PSAneCcgPyAnd2lkdGgnIDogJ2hlaWdodCddID0gMTAwIC8gdGhpcy5wYWdlci52aWV3cy5sZW5ndGggKyAnJSc7XG4gICAgICB9XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB2aWV3IHN0YXlzIGluIGZyYW1lIHdoZW4gdXNpbmcgaW5maW5pdGUgb3B0aW9uXG4gICAgICBpZiAoaW5maW5pdGUgJiYgIXRoaXMuaW5Cb3VuZHMpIHtcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICBzdHlsZVtheGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0J10gPSB0aGlzLmdldFBvc2l0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGZpbmFsbHksIGFwcGx5IGFueSBhbmltYXRpb25zXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0eWxlLCB0aGlzLnBhZ2VyLmFuaW1hdGlvbkJ1cy5nZXRTdHlsZXModGhpcykpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWaWV3O1xufShfUGFnZXJFbGVtZW50NC5kZWZhdWx0KTtcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICB2aWV3c1RvU2hvdzogMSxcbiAgdmlld3NUb01vdmU6IDEsXG4gIGFsaWduOiAwLFxuICBjb250YWluOiBmYWxzZSxcbiAgYXhpczogJ3gnLFxuICBhdXRvU2l6ZTogZmFsc2UsXG4gIGFuaW1hdGlvbnM6IFtdLFxuICBpbmZpbml0ZTogZmFsc2UsXG4gIGluc3RhbnQ6IGZhbHNlLFxuICBzd2lwZTogdHJ1ZSxcbiAgc3dpcGVUaHJlc2hvbGQ6IDAuNSxcbiAgZmxpY2tUaW1lb3V0OiAzMDAsXG4gIGFjY2Vzc2liaWxpdHk6IHRydWVcbn07XG5cbnZhciBQYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGFnZXIoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFnZXIpO1xuXG4gICAgdGhpcy5oeWRyYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMzLmZyYW1lLnNldFNpemUoKTtcbiAgICAgIF90aGlzMy50cmFjay5zZXRTaXplKCk7XG4gICAgICBfdGhpczMudmlld3MuZm9yRWFjaChmdW5jdGlvbiAodmlldykge1xuICAgICAgICB2aWV3LnNldFNpemUoKTtcbiAgICAgICAgdmlldy5zZXRUYXJnZXQoKTtcbiAgICAgIH0pO1xuICAgICAgX3RoaXMzLnNldFBvc2l0aW9uVmFsdWUoKTtcbiAgICAgIF90aGlzMy5zZXRWaWV3U3R5bGVzKCk7XG4gICAgICBfdGhpczMuZW1pdCgnaHlkcmF0ZWQnKTtcbiAgICB9O1xuXG4gICAgdmFyIGVtaXR0ZXIgPSAoMCwgX21pdHQyLmRlZmF1bHQpKCk7XG5cbiAgICB0aGlzLm9uID0gZW1pdHRlci5vbjtcbiAgICB0aGlzLmVtaXQgPSBlbWl0dGVyLmVtaXQ7XG4gICAgdGhpcy5vZmYgPSBlbWl0dGVyLm9mZjtcblxuICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRJbmRleCA9IDA7XG4gICAgdGhpcy5jdXJyZW50VmlldyA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50VHdlZW4gPSAwO1xuICAgIHRoaXMudHJhY2tQb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5pc1N3aXBpbmcgPSBmYWxzZTtcblxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmFuaW1hdGlvbkJ1cyA9IG5ldyBfYW5pbWF0aW9uQnVzMi5kZWZhdWx0KHtcbiAgICAgIGFuaW1hdGlvbnM6IHRoaXMub3B0aW9ucy5hbmltYXRpb25zLFxuICAgICAgb3JpZ2luOiBmdW5jdGlvbiBvcmlnaW4odmlldykge1xuICAgICAgICByZXR1cm4gdmlldy5vcmlnaW47XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoaXNXaW5kb3dEZWZpbmVkKSB7XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IF9yZXNpemVPYnNlcnZlclBvbHlmaWxsMi5kZWZhdWx0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLmh5ZHJhdGUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQYWdlciwgW3tcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgbGFzdE9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgIC8vIHNwcmVhZCBuZXcgb3B0aW9ucyBvdmVyIHRoZSBvbGQgb25lc1xuICAgICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIG1lcmdlIGFuaW1hdGlvbnMgaW50byBhbmltYXRpb24gYnVzXG4gICAgICB0aGlzLmFuaW1hdGlvbkJ1cy5hbmltYXRpb25zID0gdGhpcy5vcHRpb25zLmFuaW1hdGlvbnM7XG5cbiAgICAgIC8vIGZpcmUgYSB2aWV3Q2hhbmdlIGV2ZW50IHdpdGggdGhlIG5ldyBpbmRpY2llcyBpZiB2aWV3c1RvU2hvdyBoYXMgY2hhbmdlZFxuICAgICAgaWYgKGxhc3RPcHRpb25zLnZpZXdzVG9TaG93ICE9PSB0aGlzLm9wdGlvbnMudmlld3NUb1Nob3cpIHtcbiAgICAgICAgdGhpcy5lbWl0KCd2aWV3Q2hhbmdlJywgdGhpcy5nZXRDdXJyZW50SW5kaWNpZXMoKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWRkRnJhbWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRGcmFtZShub2RlKSB7XG4gICAgICB0aGlzLmZyYW1lID0gbmV3IF9QYWdlckVsZW1lbnQ0LmRlZmF1bHQoe1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBwYWdlcjogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWRkVHJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUcmFjayhub2RlKSB7XG4gICAgICB0aGlzLnRyYWNrID0gbmV3IFRyYWNrKHtcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgcGFnZXI6IHRoaXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FkZFZpZXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRWaWV3KG5vZGUpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMudmlld3MubGVuZ3RoO1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVmlldyh7XG4gICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgcGFnZXI6IHRoaXNcbiAgICAgIH0pO1xuXG4gICAgICAvLyBhZGQgdmlldyB0byBjb2xsZWN0aW9uXG4gICAgICB0aGlzLnZpZXdzLnB1c2godmlldyk7XG5cbiAgICAgIC8vIHNldCB0aGlzIGFzIHRoZSBmaXJzdCB2aWV3IGlmIHRoZXJlIGlzbid0IG9uZSB5ZXRcbiAgICAgIGlmICghdGhpcy5jdXJyZW50Vmlldykge1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRWaWV3KHtcbiAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgc3VwcHJlc3NFdmVudDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gbGlzdGVuIGZvciB3aWR0aCBhbmQgaGVpZ2h0IGNoYW5nZXNcbiAgICAgIGlmIChpc1dpbmRvd0RlZmluZWQpIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBmaXJlIGFuIGV2ZW50XG4gICAgICB0aGlzLmVtaXQoJ3ZpZXdBZGRlZCcpO1xuXG4gICAgICByZXR1cm4gdmlldztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmVWaWV3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlVmlldyh2aWV3KSB7XG4gICAgICAvLyBmaWx0ZXIgb3V0IHZpZXdcbiAgICAgIHRoaXMudmlld3MgPSB0aGlzLnZpZXdzLmZpbHRlcihmdW5jdGlvbiAoX3ZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcgIT09IF92aWV3O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHN0b3Agb2JzZXJ2aW5nIG5vZGVcbiAgICAgIGlmIChpc1dpbmRvd0RlZmluZWQpIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KHZpZXcubm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGZpcmUgYW4gZXZlbnRcbiAgICAgIHRoaXMuZW1pdCgndmlld1JlbW92ZWQnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwcmV2JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJldigpIHtcbiAgICAgIHRoaXMuc2V0Q3VycmVudFZpZXcoeyBkaXJlY3Rpb246IC0xIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25leHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdGhpcy5zZXRDdXJyZW50Vmlldyh7IGRpcmVjdGlvbjogMSB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRDdXJyZW50VmlldycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEN1cnJlbnRWaWV3KF9yZWYyKSB7XG4gICAgICB2YXIgX3JlZjIkZGlyZWN0aW9uID0gX3JlZjIuZGlyZWN0aW9uLFxuICAgICAgICAgIGRpcmVjdGlvbiA9IF9yZWYyJGRpcmVjdGlvbiA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYyJGRpcmVjdGlvbixcbiAgICAgICAgICBfcmVmMiRpbmRleCA9IF9yZWYyLmluZGV4LFxuICAgICAgICAgIGluZGV4ID0gX3JlZjIkaW5kZXggPT09IHVuZGVmaW5lZCA/IHRoaXMuY3VycmVudEluZGV4IDogX3JlZjIkaW5kZXgsXG4gICAgICAgICAgX3JlZjIkc3VwcHJlc3NFdmVudCA9IF9yZWYyLnN1cHByZXNzRXZlbnQsXG4gICAgICAgICAgc3VwcHJlc3NFdmVudCA9IF9yZWYyJHN1cHByZXNzRXZlbnQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZjIkc3VwcHJlc3NFdmVudDtcbiAgICAgIHZhciBfb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICB2aWV3c1RvTW92ZSA9IF9vcHRpb25zLnZpZXdzVG9Nb3ZlLFxuICAgICAgICAgIGluZmluaXRlID0gX29wdGlvbnMuaW5maW5pdGU7XG5cbiAgICAgIHZhciBuZXdJbmRleCA9IGluZGV4ICsgZGlyZWN0aW9uICogdmlld3NUb01vdmU7XG5cbiAgICAgIHZhciBwcmV2aW91c0luZGV4ID0gdGhpcy5jdXJyZW50SW5kZXg7XG4gICAgICB2YXIgY3VycmVudEluZGV4ID0gaW5maW5pdGUgPyBuZXdJbmRleCA6ICgwLCBfdXRpbHMuY2xhbXApKG5ld0luZGV4LCAwLCB0aGlzLnZpZXdzLmxlbmd0aCAtIDEpO1xuXG4gICAgICB2YXIgcHJldmlvdXNWaWV3ID0gdGhpcy5nZXRWaWV3KHByZXZpb3VzSW5kZXgpO1xuICAgICAgdmFyIGN1cnJlbnRWaWV3ID0gdGhpcy5nZXRWaWV3KGN1cnJlbnRJbmRleCk7XG5cbiAgICAgIC8vIHNldCBjdXJyZW50IGluZGV4IGFuZCB2aWV3XG4gICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICAgIHRoaXMuY3VycmVudFZpZXcgPSBjdXJyZW50VmlldztcblxuICAgICAgLy8gc3dhcCBjdXJyZW50IHZpZXcgZmxhZ3NcbiAgICAgIHByZXZpb3VzVmlldy5zZXRDdXJyZW50KGZhbHNlKTtcbiAgICAgIGN1cnJlbnRWaWV3LnNldEN1cnJlbnQodHJ1ZSk7XG5cbiAgICAgIHZhciByYW5nZVN0YXJ0ID0gY3VycmVudEluZGV4O1xuICAgICAgdmFyIHJhbmdlRW5kID0gY3VycmVudEluZGV4ICsgdmlld3NUb01vdmUgLSAxO1xuICAgICAgdmFyIHZpZXdSYW5nZSA9ICgwLCBfdXRpbHMucmFuZ2UpKHJhbmdlU3RhcnQsIHJhbmdlRW5kLCB0aGlzLnZpZXdzLmxlbmd0aCk7XG5cbiAgICAgIC8vIHNldCBmbGFncyBmb3Igd2hpY2ggdmlld3MgYXJlIGN1cnJlbnRseSBzaG93aW5nXG4gICAgICB0aGlzLnZpZXdzLmZvckVhY2goZnVuY3Rpb24gKHZpZXcsIGluZGV4KSB7XG4gICAgICAgIHZpZXcuc2V0VmlzaWJsZShpbmRleCA9PT0gY3VycmVudEluZGV4KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBzZXQgdGhlIHRyYWNrIHBvc2l0aW9uIHRvIHRoZSBuZXcgdmlld1xuICAgICAgdGhpcy5zZXRQb3NpdGlvblZhbHVlKCk7XG5cbiAgICAgIGlmICghc3VwcHJlc3NFdmVudCkge1xuICAgICAgICB0aGlzLmVtaXQoJ3ZpZXdDaGFuZ2UnLCB0aGlzLmdldEN1cnJlbnRJbmRpY2llcygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRQb3NpdGlvblZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb25WYWx1ZSgpIHtcbiAgICAgIHZhciB0cmFja1Bvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLmN1cnJlbnRWaWV3ID8gdGhpcy5jdXJyZW50Vmlldy50YXJnZXQgOiAwO1xuXG4gICAgICBpZiAoIXRoaXMuaXNTd2lwaW5nKSB7XG4gICAgICAgIHZhciBfb3B0aW9uczIgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICB2aWV3c1RvU2hvdyA9IF9vcHRpb25zMi52aWV3c1RvU2hvdyxcbiAgICAgICAgICAgIGF1dG9TaXplID0gX29wdGlvbnMyLmF1dG9TaXplLFxuICAgICAgICAgICAgaW5maW5pdGUgPSBfb3B0aW9uczIuaW5maW5pdGUsXG4gICAgICAgICAgICBjb250YWluID0gX29wdGlvbnMyLmNvbnRhaW47XG5cbiAgICAgICAgdmFyIHRyYWNrU2l6ZSA9IHRoaXMuZ2V0VHJhY2tTaXplKCk7XG5cbiAgICAgICAgaWYgKGluZmluaXRlKSB7XG4gICAgICAgICAgLy8gd2Ugb2Zmc2V0IGJ5IGEgdHJhY2sgbXVsdGlwbGllciBzbyBpbmZpbml0ZSBhbmltYXRpb24gY2FuIHRha2UgYWR2YW50YWdlIG9mXG4gICAgICAgICAgLy8gcGh5c2ljcyBieSBhbmltYXRpbmcgdG8gYSBsYXJnZSB2YWx1ZSwgdGhlIGZpbmFsIHZhbHVlIHByb3ZpZGVkIGluIGdldFRyYW5zZm9ybVZhbHVlXG4gICAgICAgICAgLy8gd2lsbCByZXR1cm4gdGhlIHByb3BlciB3cmFwcGVkIHZhbHVlXG4gICAgICAgICAgdHJhY2tQb3NpdGlvbiAtPSAoTWF0aC5mbG9vcih0aGlzLmN1cnJlbnRJbmRleCAvIHRoaXMudmlld3MubGVuZ3RoKSB8fCAwKSAqIHRyYWNrU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250YWluKSB7XG4gICAgICAgICAgdmFyIHRyYWNrRW5kT2Zmc2V0ID0gdmlld3NUb1Nob3cgPT09ICdhdXRvJyAmJiBhdXRvU2l6ZSB8fCB2aWV3c1RvU2hvdyA8PSAxID8gMCA6IHRoaXMuZ2V0RnJhbWVTaXplKHsgYXV0b1NpemU6IGZhbHNlIH0pO1xuICAgICAgICAgIHRyYWNrUG9zaXRpb24gPSAoMCwgX3V0aWxzLmNsYW1wKSh0cmFja1Bvc2l0aW9uLCB0cmFja0VuZE9mZnNldCAtIHRyYWNrU2l6ZSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy50cmFja1Bvc2l0aW9uID0gdHJhY2tQb3NpdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRWaWV3U3R5bGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Vmlld1N0eWxlcygpIHtcbiAgICAgIHZhciB0cmFja1Bvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIF9vcHRpb25zMyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBpbmZpbml0ZSA9IF9vcHRpb25zMy5pbmZpbml0ZSxcbiAgICAgICAgICBhbGlnbiA9IF9vcHRpb25zMy5hbGlnbjtcblxuICAgICAgdmFyIGZyYW1lU2l6ZSA9IHRoaXMuZ2V0RnJhbWVTaXplKCk7XG4gICAgICB2YXIgdHJhY2tTaXplID0gdGhpcy5nZXRUcmFja1NpemUoKTtcbiAgICAgIHZhciB3cmFwcGVkdHJhY2tQb3NpdGlvbiA9ICgwLCBfdXRpbHMubW9kdWxvKSh0cmFja1Bvc2l0aW9uLCAtdHJhY2tTaXplKTtcblxuICAgICAgdGhpcy52aWV3cy5yZWR1Y2UoZnVuY3Rpb24gKGxhc3RQb3NpdGlvbiwgdmlldywgaW5kZXgpIHtcbiAgICAgICAgdmFyIHZpZXdTaXplID0gdmlldy5nZXRTaXplKCk7XG4gICAgICAgIHZhciBuZXh0UG9zaXRpb24gPSBsYXN0UG9zaXRpb24gKyB2aWV3U2l6ZTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbGFzdFBvc2l0aW9uO1xuXG4gICAgICAgIGlmIChuZXh0UG9zaXRpb24gKyB2aWV3U2l6ZSAqIGFsaWduIDwgTWF0aC5hYnMod3JhcHBlZHRyYWNrUG9zaXRpb24pKSB7XG4gICAgICAgICAgLy8gc2hpZnQgdmlld3MgYXJvdW5kIHNvIHRoZXkgYXJlIGFsd2F5cyB2aXNpYmxlIGluIGZyYW1lXG4gICAgICAgICAgaWYgKGluZmluaXRlKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiArPSB0cmFja1NpemUgLSBsYXN0UG9zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIHZpZXcuaW5Cb3VuZHMgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2aWV3LmluQm91bmRzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZpZXcuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB2aWV3LnNldE9yaWdpbih0cmFja1Bvc2l0aW9uKTtcblxuICAgICAgICByZXR1cm4gbmV4dFBvc2l0aW9uO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0TnVtZXJpY1ZpZXdzVG9TaG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TnVtZXJpY1ZpZXdzVG9TaG93KCkge1xuICAgICAgcmV0dXJuIGlzTmFOKHRoaXMub3B0aW9ucy52aWV3c1RvU2hvdykgPyAxIDogdGhpcy5vcHRpb25zLnZpZXdzVG9TaG93O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldE1heERpbWVuc2lvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhEaW1lbnNpb25zKGluZGljZXMpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgYXhpcyA9IHRoaXMub3B0aW9ucy5heGlzO1xuXG4gICAgICB2YXIgd2lkdGhzID0gW107XG4gICAgICB2YXIgaGVpZ2h0cyA9IFtdO1xuXG4gICAgICBpbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciB2aWV3ID0gaXNOYU4oaW5kZXgpID8gaW5kZXggOiBfdGhpczQuZ2V0VmlldyhpbmRleCk7XG4gICAgICAgIHdpZHRocy5wdXNoKHZpZXcuZ2V0U2l6ZSgnd2lkdGgnKSk7XG4gICAgICAgIGhlaWdodHMucHVzaCh2aWV3LmdldFNpemUoJ2hlaWdodCcpKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogYXhpcyA9PT0gJ3gnID8gKDAsIF91dGlscy5zdW0pKHdpZHRocykgOiAoMCwgX3V0aWxzLm1heCkod2lkdGhzKSxcbiAgICAgICAgaGVpZ2h0OiBheGlzID09PSAneScgPyAoMCwgX3V0aWxzLnN1bSkoaGVpZ2h0cykgOiAoMCwgX3V0aWxzLm1heCkoaGVpZ2h0cylcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q3VycmVudEluZGljaWVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q3VycmVudEluZGljaWVzKCkge1xuICAgICAgdmFyIF9vcHRpb25zNCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBpbmZpbml0ZSA9IF9vcHRpb25zNC5pbmZpbml0ZSxcbiAgICAgICAgICBjb250YWluID0gX29wdGlvbnM0LmNvbnRhaW47XG5cbiAgICAgIHZhciBjdXJyZW50Vmlld3MgPSBbXTtcbiAgICAgIHZhciB2aWV3c1RvU2hvdyA9IGlzTmFOKHRoaXMub3B0aW9ucy52aWV3c1RvU2hvdykgPyAxIDogdGhpcy5vcHRpb25zLnZpZXdzVG9TaG93O1xuICAgICAgdmFyIG1pbkluZGV4ID0gdGhpcy5jdXJyZW50SW5kZXg7XG4gICAgICB2YXIgbWF4SW5kZXggPSB0aGlzLmN1cnJlbnRJbmRleCArICh2aWV3c1RvU2hvdyAtIDEpO1xuXG4gICAgICBpZiAoY29udGFpbikge1xuICAgICAgICAvLyBpZiBjb250YWluaW5nLCB3ZSBuZWVkIHRvIGNsYW1wIHRoZSBzdGFydCBhbmQgZW5kIGluZGV4ZXMgc28gd2Ugb25seSByZXR1cm4gd2hhdCdzIGluIHZpZXdcbiAgICAgICAgbWluSW5kZXggPSAoMCwgX3V0aWxzLmNsYW1wKShtaW5JbmRleCwgMCwgdGhpcy52aWV3cy5sZW5ndGggLSB2aWV3c1RvU2hvdyk7XG4gICAgICAgIG1heEluZGV4ID0gKDAsIF91dGlscy5jbGFtcCkobWF4SW5kZXgsIDAsIHRoaXMudmlld3MubGVuZ3RoIC0gMSk7XG4gICAgICAgIGZvciAodmFyIGkgPSBtaW5JbmRleDsgaSA8PSBtYXhJbmRleDsgaSsrKSB7XG4gICAgICAgICAgY3VycmVudFZpZXdzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gbWluSW5kZXg7IF9pIDw9IG1heEluZGV4OyBfaSsrKSB7XG4gICAgICAgICAgY3VycmVudFZpZXdzLnB1c2goaW5maW5pdGUgPyAoMCwgX3V0aWxzLm1vZHVsbykoX2ksIHRoaXMudmlld3MubGVuZ3RoKSA6ICgwLCBfdXRpbHMuY2xhbXApKF9pLCAwLCB0aGlzLnZpZXdzLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3VycmVudFZpZXdzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEZyYW1lU2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZyYW1lU2l6ZSgpIHtcbiAgICAgIHZhciBfcmVmMyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgX3JlZjMkYXV0b1NpemUgPSBfcmVmMy5hdXRvU2l6ZSxcbiAgICAgICAgICBhdXRvU2l6ZSA9IF9yZWYzJGF1dG9TaXplID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuYXV0b1NpemUgOiBfcmVmMyRhdXRvU2l6ZSxcbiAgICAgICAgICBfcmVmMyRmdWxsU2l6ZSA9IF9yZWYzLmZ1bGxTaXplLFxuICAgICAgICAgIGZ1bGxTaXplID0gX3JlZjMkZnVsbFNpemUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZjMkZnVsbFNpemU7XG5cbiAgICAgIHZhciBkaW1lbnNpb25zID0ge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy52aWV3cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGF1dG9TaXplKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRWaWV3cyA9IHRoaXMuZ2V0Q3VycmVudEluZGljaWVzKCk7XG4gICAgICAgICAgZGltZW5zaW9ucyA9IHRoaXMuZ2V0TWF4RGltZW5zaW9ucyhjdXJyZW50Vmlld3MpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJhbWUpIHtcbiAgICAgICAgICBkaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMuZnJhbWUuZ2V0U2l6ZSgnd2lkdGgnKSxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5mcmFtZS5nZXRTaXplKCdoZWlnaHQnKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZ1bGxTaXplKSB7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb25zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbnNbdGhpcy5vcHRpb25zLmF4aXMgPT09ICd4JyA/ICd3aWR0aCcgOiAnaGVpZ2h0J107XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VHJhY2tTaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJhY2tTaXplKCkge1xuICAgICAgdmFyIGluY2x1ZGVMYXN0U2xpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG5cbiAgICAgIHZhciBsYXN0SW5kZXggPSBpbmNsdWRlTGFzdFNsaWRlID8gdGhpcy52aWV3cy5sZW5ndGggOiB0aGlzLnZpZXdzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgc2l6ZSA9IDA7XG4gICAgICB0aGlzLnZpZXdzLnNsaWNlKDAsIGxhc3RJbmRleCkuZm9yRWFjaChmdW5jdGlvbiAodmlldykge1xuICAgICAgICBzaXplICs9IHZpZXcuZ2V0U2l6ZSgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRWaWV3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmlldyhpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlld3NbKDAsIF91dGlscy5tb2R1bG8pKGluZGV4LCB0aGlzLnZpZXdzLmxlbmd0aCldO1xuICAgIH1cblxuICAgIC8vIHdoZXJlIHRoZSB2aWV3IHNob3VsZCBzdGFydFxuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTdGFydENvb3JkcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXJ0Q29vcmRzKGluZGV4KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gMDtcbiAgICAgIHRoaXMudmlld3Muc2xpY2UoMCwgaW5kZXgpLmZvckVhY2goZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgdGFyZ2V0IC09IHZpZXcuZ2V0U2l6ZSgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8vIGhvdyBtdWNoIHRvIG9mZnNldCB0aGUgdmlldyBkZWZpbmVkIGJ5IHRoZSBhbGlnbiBvcHRpb25cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0QWxpZ25PZmZzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBbGlnbk9mZnNldCh2aWV3KSB7XG4gICAgICB2YXIgZnJhbWVTaXplID0gdGhpcy5nZXRGcmFtZVNpemUoeyBhdXRvU2l6ZTogZmFsc2UgfSk7XG4gICAgICB2YXIgdmlld1NpemUgPSB2aWV3LmdldFNpemUoKTtcbiAgICAgIHJldHVybiAoZnJhbWVTaXplIC0gdmlld1NpemUpICogdGhpcy5vcHRpb25zLmFsaWduO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFBvc2l0aW9uVmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb3NpdGlvblZhbHVlKCkge1xuICAgICAgdmFyIHRyYWNrUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMudHJhY2tQb3NpdGlvbjtcbiAgICAgIHZhciBfb3B0aW9uczUgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgaW5maW5pdGUgPSBfb3B0aW9uczUuaW5maW5pdGUsXG4gICAgICAgICAgY29udGFpbiA9IF9vcHRpb25zNS5jb250YWluO1xuXG4gICAgICB2YXIgcG9zaXRpb24gPSB7IHg6IDAsIHk6IDBcblxuICAgICAgICAvLyBzdG9yZSB0aGUgY3VycmVudCBhbmltYXRlZCB2YWx1ZSBzbyB3ZSBjYW4gcmVmZXJlbmNlIGl0IGxhdGVyXG4gICAgICB9O3RoaXMuY3VycmVudFR3ZWVuID0gdHJhY2tQb3NpdGlvbjtcblxuICAgICAgLy8gd3JhcCB0aGUgdHJhY2sgcG9zaXRpb24gaWYgdGhpcyBpcyBhbiBpbmZpbml0ZSB0cmFja1xuICAgICAgaWYgKGluZmluaXRlKSB7XG4gICAgICAgIHZhciB0cmFja1NpemUgPSB0aGlzLmdldFRyYWNrU2l6ZSgpO1xuICAgICAgICB0cmFja1Bvc2l0aW9uID0gKDAsIF91dGlscy5tb2R1bG8pKHRyYWNrUG9zaXRpb24sIC10cmFja1NpemUpIHx8IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgYSBcInNjcm9sbFwiIGV2ZW50IHNvIHdlIGNhbiBkbyB0aGluZ3MgYmFzZWQgb24gdGhlIHByb2dyZXNzIG9mIHRoZSB0cmFja1xuICAgICAgdGhpcy5lbWl0KCdzY3JvbGwnLCB7XG4gICAgICAgIHByb2dyZXNzOiB0cmFja1Bvc2l0aW9uIC8gdGhpcy5nZXRUcmFja1NpemUoZmFsc2UpLFxuICAgICAgICBwb3NpdGlvbjogdHJhY2tQb3NpdGlvblxuICAgICAgfSk7XG5cbiAgICAgIC8vIHNldCB0aGUgcHJvcGVyIHRyYW5zZm9ybSBheGlzIGJhc2VkIG9uIG91ciBvcHRpb25zXG4gICAgICBwb3NpdGlvblt0aGlzLm9wdGlvbnMuYXhpc10gPSB0cmFja1Bvc2l0aW9uO1xuXG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVzZXRWaWV3SW5kZXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldFZpZXdJbmRleCgpIHtcbiAgICAgIC8vIHJlc2V0IGJhY2sgdG8gYSBub3JtYWwgaW5kZXhcbiAgICAgIHRoaXMuc2V0Q3VycmVudFZpZXcoe1xuICAgICAgICBpbmRleDogKDAsIF91dGlscy5tb2R1bG8pKHRoaXMuY3VycmVudEluZGV4LCB0aGlzLnZpZXdzLmxlbmd0aCksXG4gICAgICAgIHN1cHByZXNzRXZlbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQYWdlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUGFnZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///209\n")},724:function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PagerElement = function () {\n  function PagerElement(_ref) {\n    var node = _ref.node,\n        pager = _ref.pager,\n        width = _ref.width,\n        height = _ref.height;\n\n    _classCallCheck(this, PagerElement);\n\n    this.node = node;\n    this.pager = pager;\n    this.x = this.y = 0;\n    this.setSize(width, height);\n  }\n\n  _createClass(PagerElement, [{\n    key: 'setSize',\n    value: function setSize(width, height) {\n      this.width = width || this.node.offsetWidth;\n      this.height = height || this.node.offsetHeight;\n    }\n  }, {\n    key: 'setPosition',\n    value: function setPosition(position) {\n      this[this.pager.options.axis] = position;\n    }\n  }, {\n    key: 'getSize',\n    value: function getSize(dimension) {\n      if (dimension === 'width' || dimension === 'height') {\n        return this[dimension];\n      } else {\n        var axis = this.pager.options.axis;\n        return this[axis === 'x' ? 'width' : 'height'];\n      }\n    }\n  }, {\n    key: 'getPosition',\n    value: function getPosition() {\n      return this[this.pager.options.axis];\n    }\n  }]);\n\n  return PagerElement;\n}();\n\nexports.default = PagerElement;\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXZpZXctcGFnZXIvbGliL1BhZ2VyRWxlbWVudC5qcz9hZTczIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFBhZ2VyRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGFnZXJFbGVtZW50KF9yZWYpIHtcbiAgICB2YXIgbm9kZSA9IF9yZWYubm9kZSxcbiAgICAgICAgcGFnZXIgPSBfcmVmLnBhZ2VyLFxuICAgICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhZ2VyRWxlbWVudCk7XG5cbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMucGFnZXIgPSBwYWdlcjtcbiAgICB0aGlzLnggPSB0aGlzLnkgPSAwO1xuICAgIHRoaXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQYWdlckVsZW1lbnQsIFt7XG4gICAga2V5OiAnc2V0U2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IHRoaXMubm9kZS5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IHRoaXMubm9kZS5vZmZzZXRIZWlnaHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0UG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgdGhpc1t0aGlzLnBhZ2VyLm9wdGlvbnMuYXhpc10gPSBwb3NpdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2l6ZShkaW1lbnNpb24pIHtcbiAgICAgIGlmIChkaW1lbnNpb24gPT09ICd3aWR0aCcgfHwgZGltZW5zaW9uID09PSAnaGVpZ2h0Jykge1xuICAgICAgICByZXR1cm4gdGhpc1tkaW1lbnNpb25dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGF4aXMgPSB0aGlzLnBhZ2VyLm9wdGlvbnMuYXhpcztcbiAgICAgICAgcmV0dXJuIHRoaXNbYXhpcyA9PT0gJ3gnID8gJ3dpZHRoJyA6ICdoZWlnaHQnXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXNbdGhpcy5wYWdlci5vcHRpb25zLmF4aXNdO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQYWdlckVsZW1lbnQ7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFBhZ2VyRWxlbWVudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///724\n")},735:function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(514);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Keyboard = function () {\n  function Keyboard(pager) {\n    var _this = this;\n\n    _classCallCheck(this, Keyboard);\n\n    this._handleKeyDown = function (e) {\n      // handle respective key controls\n      switch (e.key) {\n        // move to the previous view\n        case 'ArrowUp':\n        case 'ArrowLeft':\n          _this.pager.prev();\n          return;\n\n        // move to the next view\n        case 'ArrowDown':\n        case 'ArrowRight':\n        case ' ':\n          _this.pager.next();\n          return;\n\n        // move to first view\n        case 'Home':\n          _this.pager.setCurrentView({ index: 0 });\n          return;\n\n        // move to last view\n        case 'End':\n          _this.pager.setCurrentView({ index: _this.pager.views.length - 1 });\n          return;\n      }\n\n      // 1 - 9 keys mapped to respective slide number\n      var maxNumKey = (0, _utils.clamp)(_this.pager.views.length, 0, 9);\n\n      for (var i = 1; i <= maxNumKey; i++) {\n        if (+e.key === i) {\n          _this.pager.setCurrentView({ index: i - 1 });\n        }\n      }\n    };\n\n    this.pager = pager;\n  }\n\n  _createClass(Keyboard, [{\n    key: 'getEvents',\n    value: function getEvents() {\n      var keyboardEvents = {};\n\n      if (this.pager.options.accessibility) {\n        keyboardEvents.onKeyDown = this._handleKeyDown;\n      }\n\n      return keyboardEvents;\n    }\n  }]);\n\n  return Keyboard;\n}();\n\nexports.default = Keyboard;\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXZpZXctcGFnZXIvbGliL0tleWJvYXJkLmpzP2MyZWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgS2V5Ym9hcmQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEtleWJvYXJkKHBhZ2VyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBLZXlib2FyZCk7XG5cbiAgICB0aGlzLl9oYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vIGhhbmRsZSByZXNwZWN0aXZlIGtleSBjb250cm9sc1xuICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICAvLyBtb3ZlIHRvIHRoZSBwcmV2aW91cyB2aWV3XG4gICAgICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgICAgIF90aGlzLnBhZ2VyLnByZXYoKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgLy8gbW92ZSB0byB0aGUgbmV4dCB2aWV3XG4gICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICBfdGhpcy5wYWdlci5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vIG1vdmUgdG8gZmlyc3Qgdmlld1xuICAgICAgICBjYXNlICdIb21lJzpcbiAgICAgICAgICBfdGhpcy5wYWdlci5zZXRDdXJyZW50Vmlldyh7IGluZGV4OiAwIH0pO1xuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAvLyBtb3ZlIHRvIGxhc3Qgdmlld1xuICAgICAgICBjYXNlICdFbmQnOlxuICAgICAgICAgIF90aGlzLnBhZ2VyLnNldEN1cnJlbnRWaWV3KHsgaW5kZXg6IF90aGlzLnBhZ2VyLnZpZXdzLmxlbmd0aCAtIDEgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyAxIC0gOSBrZXlzIG1hcHBlZCB0byByZXNwZWN0aXZlIHNsaWRlIG51bWJlclxuICAgICAgdmFyIG1heE51bUtleSA9ICgwLCBfdXRpbHMuY2xhbXApKF90aGlzLnBhZ2VyLnZpZXdzLmxlbmd0aCwgMCwgOSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG1heE51bUtleTsgaSsrKSB7XG4gICAgICAgIGlmICgrZS5rZXkgPT09IGkpIHtcbiAgICAgICAgICBfdGhpcy5wYWdlci5zZXRDdXJyZW50Vmlldyh7IGluZGV4OiBpIC0gMSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnBhZ2VyID0gcGFnZXI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoS2V5Ym9hcmQsIFt7XG4gICAga2V5OiAnZ2V0RXZlbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RXZlbnRzKCkge1xuICAgICAgdmFyIGtleWJvYXJkRXZlbnRzID0ge307XG5cbiAgICAgIGlmICh0aGlzLnBhZ2VyLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSkge1xuICAgICAgICBrZXlib2FyZEV2ZW50cy5vbktleURvd24gPSB0aGlzLl9oYW5kbGVLZXlEb3duO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2V5Ym9hcmRFdmVudHM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEtleWJvYXJkO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLZXlib2FyZDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///735\n")}}]);